<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>操作系统学习总结 | Yexin的个人主页</title>
    <meta name="author" content="yexin" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="Everything about yexin" />
    <meta name="baidu-site-verification" content="" />
    <meta name="keywords" content="yexin,陈天驰,陈天驰的博客,yexin的博客" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  	<link href="/asserts/css/default.css" rel="stylesheet" type="text/css" media="all">
	<script type="text/javascript" src="/asserts/js/app.js" ></script> 
</head>
<body>
	<!--头部 -->
	<header class="header">
		<div class="header-container">
			<section class="site-logo">
				<a  href="/">叶心</a>
			</section>
			<button class="collapsed " type="button" >
		        <span class="icon-bar"></span>
		        <span class="icon-bar"></span>
		        <span class="icon-bar"></span>
		    </button>
		    <div class="menu-container">
				<nav class="site-nav">
					<ul>
						<li>
							<a  href="/blog/archiveAll.html">随笔</a>
						</li>
						<li>
							<a  href="/blog/archive.html">博客</a>
						</li>
						<li>
							<a  href="/blog/categories.html">分类</a>
						</li>
						<li>
							<a  href="/blog/tags.html">标签</a>
						</li>
						<li>
							<a  href="/demo/demo.html">Demo</a>
						</li>
						<li>
							<a  href="/favour/music.html">音乐</a>
						</li>
						<li>
							<a  href="/favour/book.html">Book</a>
						</li>
						<li>
							<a  href="/about/timeline.html">时间轴</a>
						</li>
						<li>
							<a  href="/others/collection.html">收藏</a>
						</li>
						<li>
							<a  href="/about/about.html">关于</a>
						</li>
					</ul>
				</nav>
				<div class="site-search">
					<input type="text" />
				</div>
			</div>
		</div>
	</header>
	<link href="/asserts/css/blog_article_post.css" rel="stylesheet" type="text/css" media="all">
<link href="/asserts/css/blog_personCard_style.css" rel="stylesheet" type="text/css" media="all">
<link href="/asserts/css/imageBubble.css" rel="stylesheet" type="text/css" media="all">
	
	<div class="wrap">
		<div class="container">
			<!-- 左侧，内容，多说评论等-->
			<div class="col-md-9">
				<!-- 内容-->
				<div class="markdown-body">
					<!--标题区域 -->
					<div class="title-container">
					<h1 class="page-title"><a  title="操作系统学习总结">操作系统学习总结</a> </h1>
						<!-- metainfo-->
						<section class="meta clearfix">
<span class="time">
<time datetime="2017-06-18">2017-06-18</time>
</span>

| 
<span class="categories">
	分类
	    
	    <a href="/blog/categories.html#汇总" title="汇总">汇总</a>&nbsp;
	    
</span>


| 
<span class="tags">
	标签
		
		<a href="/blog/tags.html#总结" title="总结">总结</a>&nbsp;
		
</span>

| 
<span class="views">
	浏览
	<a id="busuanzi_value_page_pv"></a>&nbsp;
</span>
</section>
						<section class="right-tips">
							<span >
								学习总结
							</span>
						</section>
					</div>
					<!-- 特别推荐-->
					
					<!-- 内容区域-->
					<div class="content-container">
						 <h2 id="操作系统概述">操作系统概述</h2>

<h3 id="基本概念">基本概念</h3>
<p>计算机系统自下而上可粗分为四个部分：硬件、操作系统、应用程序和用户；操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介。
硬件，如中央处理器、内存、输入/输出设备等，提供了基本的计算资源。应用程序， 如字处理程序、电子制表软件、编译器、网络浏览器等，规定了按何种方式使用这些资源来解决用户的计算问题。操作系统控制和协调各用户的应用程序对硬件的分配与使用。
在计算机系统的运行过程中，操作系统提供了正确使用这些资源的方法。</p>

<p>综上所述，操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。</p>

<h3 id="特征">特征</h3>
<p>并发和共享是两个互为存在的条件。（资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；若系统不能对资源共享实施有效的管理，也必将影响到程序的并发执行，甚至根本无法并发执行。）</p>

<h4 id="并发">并发</h4>
<p>并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能并发执行。</p>

<h4 id="共享">共享</h4>
<p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>

<h5 id="互斥共享">互斥共享</h5>
<p>系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源。</p>

<p>为此，当进程A访问某资源时，必须先提出请求，如果此时该资源空闲，系统便可将之分配给进程A使用，此后若再有其他进程也要访问该资源时（只要A未用完）则必须等待。仅当进程A访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。</p>
<h5 id="同时访问">同时访问</h5>
<p>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即 “分时共享”。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p>

<h4 id="虚拟">虚拟</h4>
<p>在虚拟处理器技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU)在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的CPU,称为虚拟处理器。操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器。</p>
<h4 id="异步">异步</h4>
<p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>

<p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误 (就像对全局变量的访问顺序不当会导致程序出错一样）。但是只要运行环境相同，操作系统必须保证多次运行进程，都获得相同的结果。</p>

<h3 id="目标">目标</h3>
<p>提供良好的运行环境，提供更方便的服务、更高的资源利用率。</p>

<h3 id="功能">功能</h3>
<p>操作系统作为计算机系统资源的管理者，具有以下几点功能：处理机管理、 存储器管理、文件管理和设备管理。</p>
<h4 id="处理器管理">处理器管理</h4>
<p>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发时在计算机内同时运行多个进程，所以，进程何时创建、何时撤销、如何管理、如何避免冲突、.合理共享就是进程管理的最主要的任务。进程管理的主要功能有：进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h4 id="存储器管理">存储器管理</h4>
<p>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用以及提高内存的利用率，主要包括内存分配、地址映射、内存保护与共享和内存扩充等功能。</p>
<h4 id="文件管理">文件管理</h4>
<p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p>
<h4 id="设备管理">设备管理</h4>
<p>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虛拟设备等功能。</p>

<h3 id="接口">接口</h3>
<p>操作系统作为用户与计算机硬件系统之间的接口，为方便用户使用计算机，提供了用户接口。（一类是命令接口，用户利用这些操作命令来组织和控制作业的执行；另一类是程序接口，编程人员可以使用它们来请求操作系统服务。）</p>
<h4 id="命令接口">命令接口</h4>
<p>使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可以将命令接口分为联机命令接口和脱机命令接口。</p>

<p>联机命令接口又称交互式命令接口，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入完一条命令，控制权就转入操作系统的命令解释程序，然后由命令解释程序对输入的命令解释并执行，完成指定的功能。之后，控制权又转回到控制台或终端，此时用户又可以输入下一条命令。</p>

<p>脱机命令接口又称批处理命令接口，即适用于批处理系统，它由一组作业控制命令（或称作业控制语句）组成。脱机用户不能直接干预作业的运行，应事先用相应的作业控制命令穹成一份作业操作说明书，连同作业一起提交给系统。当系统调度到该作业时，由系统中的命令解释程序对作业说明书上的命令或作业控制语句遂条解释执行，从而间接地控制作业的运行。</p>
<h4 id="程序接口">程序接口</h4>
<p>程序接口由一组系统调用命会（简称系统调用，也称广义指令）组成。用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。用户在程序中可以直接使用这组系统调用命令向系统提出各种服务要求，如使用各种外部设备，进行有关磁盘文件的操作，申请分配和回收内存以及其他各种控制要求。</p>

<p>而当前最为流行的是图形用户界面(GUI)即图形接口，用户通过鼠标和键盘，在图形界面上单击或使用快捷键就能很方便地使用操作系统。有些系统提供了上述三种接口，但 GUI 最终是通过调用程序接口实现的，严格地说它不属于操作系统的一部分。</p>
<h3 id="发展">发展</h3>
<ul>
  <li>手工操作阶段</li>
  <li>批处理阶段（单道批处理系统，多道批处理系统）</li>
  <li>分时操作系统（同时性，交互性，独立性，及时性）</li>
  <li>实时操作系统（及时性，可靠性）（如：飞机订票系统、银行管理系统）</li>
  <li>网络操作系统和分布式计算机系统（分布性，并行性）</li>
  <li>个人计算机操作系统</li>
  <li>嵌入式操作系统、服务器操作系统、多处理器操作系统</li>
</ul>

<h3 id="运行机制">运行机制</h3>
<p>所谓特权指令，是指计算机中不允许用户直接使用的指令，如I/O指令、 置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等指令。操作系统在具体实现上划分了用户态（目态）和核心态（管态)，以严格区分两类程序。</p>
<h4 id="内核">内核</h4>
<p>一些与硬件关联较紧密的模块，诸如时钟管理、中断处理、设备驱动等处于最底层。其次是运行频率较髙的程序，诸如进程管理、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p>
<ul>
  <li>时钟管理</li>
  <li>中断机制（提高多道程序运行环境中CPU的利用率，现代操作系统是靠中断驱动的软件，其中有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。）</li>
  <li>原语（具有原始性，调用频繁，处于操作系统最底层，最靠近硬件）（定义原语的直接方法是关闭中断，让它的所有动作不可分割地进行完再打开中断。）</li>
  <li>系统控制数据结构及其相关的处理方案（登记状态信息的数据结构：作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表）
    <ul>
      <li>进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等。</li>
      <li>存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li>
      <li>设备管理：缓冲区管理、设备分配和回收等。</li>
    </ul>
  </li>
</ul>

<h3 id="中断与异常">中断与异常：</h3>
<ul>
  <li>内中断
    <ul>
      <li>自愿中断（指令中断）</li>
      <li>强迫中断（硬件故障，软件中断）</li>
    </ul>
  </li>
  <li>外中断（强迫中断）
    <h4 id="中断">中断</h4>
    <p>也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们与当前处理机运行的程序无关。</p>
    <h4 id="异常">异常</h4>
    <p>也称内中断、例外或陷入(Trap)，指源自CPU执行指令内部的事件，如程序的非法操作码、 地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。</p>
  </li>
</ul>

<h3 id="系统调用">系统调用</h3>
<p>所谓系统调用就是用户在程序中调用操作系统所提供的一些子功能，系统调用可以被看做特殊的公共子程序。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。</p>
<ul>
  <li>设备管理（完成设备的请求或释放，以及设备启动等功能）</li>
  <li>文件管理（完成文件的读、写、创建及删除等功能）</li>
  <li>进程控制（完成进程的创建、撤销、阻塞及唤醒等功能）</li>
  <li>进程通信（完成进程之间的消息传递或信号传递等功能）</li>
  <li>内存管理（完成内存的分配、回收以及获取作业占用内存区大小及始址等功能）</li>
</ul>

<p>由用户态转向核心态：</p>
<ul>
  <li>用户程序要求操作系统的服务，即系统调用。</li>
  <li>发生一次中断。</li>
  <li>用户程序中产生了一个错误状态。</li>
  <li>用户程序中企图执行一条特权指令。
从核心态转向用户态：</li>
  <li>由一条指令实现，这条指令也是特权命令。一般是中断返回指令。</li>
</ul>

<h3 id="体系结构">体系结构</h3>
<h4 id="大内核">大内核</h4>
<p>大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。</p>

<h4 id="微内核">微内核</h4>
<p>微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的可靠性。</p>

<h2 id="进程和线程管理">进程和线程管理</h2>

<h3 id="进程的概念">进程的概念</h3>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程(Process)的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block, PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。所谓创建进程，实质上是创建进程映像中的PCB；而撤销进程，实质上是撤销进程的PCB。值得注意的是，进程映像是静态的，进程则是动态的。（PCB是进程存在的唯一标志！）</p>

<h3 id="进程的特征">进程的特征</h3>
<ul>
  <li>动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</li>
  <li>并发性：指多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。</li>
  <li>独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li>
  <li>异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、 不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。</li>
  <li>结构性：每个进程都配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。</li>
</ul>

<h3 id="状态">状态</h3>
<ul>
  <li>运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</li>
  <li>就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。</li>
  <li>阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</li>
  <li>创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源；最后把该进程转入到就绪状态。</li>
  <li>结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。</li>
</ul>

<h3 id="转换">转换</h3>
<ul>
  <li>就绪状态 -&gt; 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。</li>
  <li>运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</li>
  <li>运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</li>
  <li>阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</li>
</ul>

<h3 id="进程的创建">进程的创建</h3>
<p>允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。
在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。</p>

<h4 id="操作系统创建一个新进程的过程如下创建原语">操作系统创建一个新进程的过程如下（创建原语)：</h4>
<ul>
  <li>为新进程分配一个唯一的进程标识号，并申请一个空白的PCB(PCB是有限的)。若PCB申请失败则创建失败。</li>
  <li>为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在PCB 中体现）。注意：这里如果资源不足（比如内存空间），并不是创建失败，而是处于”等待状态“，或称为“阻塞状态”，等待的是内存这个资源。</li>
  <li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li>
  <li>如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。</li>
</ul>

<h3 id="进程的终止">进程的终止</h3>
<p>引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</p>

<h4 id="操作系统终止进程的过程如下撤销原语">操作系统终止进程的过程如下（撤销原语）：</h4>
<ul>
  <li>根据被终止进程的标识符，检索PCB，从中读出该进程的状态。</li>
  <li>若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li>
  <li>若该进程还有子进程，则应将其所有子进程终止。</li>
  <li>将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。</li>
  <li>将该PCB从所在队列（链表）中删除。</li>
</ul>

<h3 id="进程的阻塞和唤醒">进程的阻塞和唤醒</h3>
<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</p>

<p>阻塞原语的执行过程是：</p>
<ul>
  <li>找到将要被阻塞进程的标识号对应的PCB。</li>
  <li>若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。</li>
  <li>把该PCB插入到相应事件的等待队列中去。</li>
</ul>

<p>当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。</p>

<p>唤醒原语的执行过程是：</p>
<ul>
  <li>在该事件的等待队列中找到相应进程的PCB。</li>
  <li>将其从等待队列中移出，并置其状态为就绪状态。</li>
  <li>把该PCB插入就绪队列中，等待调度程序调度。</li>
</ul>

<h3 id="进程切换">进程切换</h3>
<p>对于通常的进程，其创建、撤销以及要求由系统设备完成的I/O操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>

<p>进程切换的过程如下：</p>
<ul>
  <li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
  <li>更新PCB信息。</li>
  <li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
  <li>选择另一个进程执行，并更新其PCB。</li>
  <li>更新内存管理的数据结构。</li>
  <li>恢复处理机上下文。</li>
</ul>

<h3 id="进程组织">进程组织</h3>
<h4 id="控制块">控制块</h4>
<p>进程创建时，操作系统就新建一个PCB结构，它之后就常驻内存，任一时刻可以存取, 在进程结束时删除。
PCB是进程实体的一部分，是进程存在的唯一标志。
在一个系统中，通常存在着许多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。
为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。
目前，常用的组织方式有链接方式和索引方式两种。
链接方式将同一状态的PCB链接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。
索引方式是将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等</p>

<p>当创建一个进程时，系统为该进程建立一个PCB；当进程执行时，系统通过其PCB 了 解进程的现行状态信息，以便对其进行控制和管理；当进程结束时，系统收回其PCB,该进 程随之消亡。操作系统通过PCB表来管理和控制进程。</p>
<ul>
  <li>
    <p>进程描述信息(进程标识符：标志各个进程，每个进程都有一个并且是唯一的标识号。用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。)</p>
  </li>
  <li>
    <p>进程控制和管理信息(进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。进程优先级：描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机。)</p>
  </li>
  <li>
    <p>资源分配清单(用于说明有关内存地址空间或虚拟地址空间的状况；所打开文件的 列表和所使用的输入/输出设备信息。)</p>
  </li>
  <li>
    <p>处理机相关信息，主要指处理机中各寄存器值(当进程被切换时，处理机状态信息 都必须保存在相应的PCB中，以便在该进程重新执行时，能再从断点继续执行。)</p>
  </li>
</ul>

<h4 id="程序段">程序段</h4>
<p>程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序。</p>

<h4 id="数据段">数据段</h4>
<p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p>
<h3 id="进程通信">进程通信</h3>
<p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。</p>
<h4 id="共享存储">共享存储</h4>
<p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</p>

<p>需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</p>
<h4 id="消息传递">消息传递</h4>
<p>在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。
进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p>

<ul>
  <li>
    <p>直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p>
  </li>
  <li>
    <p>间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</p>
  </li>
</ul>

<h3 id="管道通信">管道通信</h3>
<p>管道通信是消息传递的一种特殊方式。
所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。
向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p>
<h3 id="线程">线程</h3>

<h4 id="基本概念-1">基本概念</h4>
<p>引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>

<p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。
线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。
一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。
由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p>

<p>引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元。</p>
<h4 id="与进程的比较">与进程的比较</h4>
<ul>
  <li>
    <p>调度(在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。)</p>
  </li>
  <li>
    <p>拥有资源(不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源），但线程可以访问其隶属进程的系统资源。)</p>
  </li>
  <li>
    <p>并发性(在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。)</p>
  </li>
  <li>
    <p>系统开销(由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、 I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。)</p>
  </li>
  <li>
    <p>地址空间和其他资源（如打开的文件）(进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。)</p>
  </li>
  <li>
    <p>通信方面(进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。)</p>
  </li>
</ul>

<h4 id="属性">属性</h4>
<p>在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是一个基本的可执行实体。但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。</p>

<p>线程的主要属性如下：</p>
<ul>
  <li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</li>
  <li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程。</li>
  <li>同一进程中的各个线程共享该进程所拥有的资源。</li>
  <li>线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务则可缩短进程的处理时间。</li>
  <li>一个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li>
</ul>

<h4 id="实现方式">实现方式</h4>
<p>线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread,  KLT)。内核级线程又称为内核支持的线程。</p>

<p>在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。
应用程序可以通过使用线程库设计成多线程程序。
通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。</p>

<p>在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。
内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。</p>

<p>在一些系统中，使用组合方式的多线程实现。
线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。
一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。</p>

<h4 id="多线程模型">多线程模型</h4>
<p>有些系统同时支持用户线程和内核线程由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p>
<ul>
  <li>多对一模型(将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明）。)
    <ul>
      <li>优点：线程管理是在用户空间进行的，因而效率比较高。</li>
      <li>缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。</li>
    </ul>
  </li>
  <li>一对一模型(将每个用户级线程映射到一个内核级线程。)
    <ul>
      <li>优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</li>
      <li>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</li>
    </ul>
  </li>
  <li>多对多模型(将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。)
    <ul>
      <li>特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。</li>
    </ul>
  </li>
</ul>

<h3 id="调度">调度</h3>
<h4 id="基本概念-2">基本概念</h4>
<p>在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。
处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、髙效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。
处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题。</p>
<h4 id="层次">层次</h4>
<p>一个作业从提交开始直到完成，要经历以下是三个层次:</p>
<ul>
  <li>作业调度(又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它们获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。)
    <ul>
      <li>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</li>
    </ul>
  </li>
  <li>中级调度(又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。)</li>
  <li>进程调度(又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。)</li>
</ul>

<h4 id="三级调度的联系">三级调度的联系</h4>
<ul>
  <li>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li>
  <li>作业调度次数少，中级调度次数略多，进程调度频率最高。</li>
  <li>进程调度是最基本的，不可或缺</li>
</ul>

<h4 id="调度的时机切换与过程">调度的时机、切换与过程</h4>
<p>进程调度和切换程序是操作系统内核程序。当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。</p>

<p>不能进行进程的调度与切换的情况:</p>
<ul>
  <li>在处理中断的过程中：中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</li>
  <li>进程在操作系统内核程序临界区中：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</li>
  <li>其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</li>
</ul>

<p>应该进行进程调度与切换的情况有：</p>
<ul>
  <li>当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度。</li>
  <li>当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。</li>
</ul>

<h4 id="进程调度方式">进程调度方式</h4>
<p>所谓进程调度方式是指当某一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更髙的进程进入就绪队列，此时应如何分配处理机。</p>

<p>通常有以下两种进程调度方式：</p>
<ul>
  <li>非剥夺调度方式，又称非抢占方式。是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。
    <ul>
      <li>在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</li>
    </ul>
  </li>
  <li>剥夺调度方式，又称抢占方式。是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。
    <ul>
      <li>釆用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有：优先权、短进程优先和时间片原则等。</li>
    </ul>
  </li>
</ul>

<h4 id="基本准则">基本准则</h4>
<ul>
  <li>CPU利用率(CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最髙。)</li>
  <li>系统吞吐量(表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。)</li>
  <li>周转时间(是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入/输出操作所花费时间的总和。)
    <ul>
      <li>作业的周转时间可用公式表示如下：周转时间 = 作业完成时间 - 作业提交时间</li>
      <li>平均周转时间是指多个作业周转时间的平均值：平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n</li>
      <li>带权周转时间是指作业周转时间与作业实际运行时间的比值：带权周转时间 = 作业周转时间 / 作业实际运行时间</li>
      <li>平均带权周转时间是指多个作业带权周转时间的平均值：平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n</li>
    </ul>
  </li>
  <li>等待时间(是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。)</li>
  <li>响应时间(是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。)</li>
</ul>


					</div>
					<!-- 上一篇与下一篇-->
					<section align="right" class="post-next-prev">
					  <span>
					    <a  href="/2017/06/17/pythoncrawler.html" class="active"  >上一篇</a>
					    &nbsp;&nbsp;&nbsp;
					    <a   class="pageNavInvalid"  >下一篇</a>
					  </span>
					</section>
				</div>
				<!-- 多说-->
				
				
				
			</div>
			
			<!-- 右侧包括个人介绍，TOC菜单-->
			<div class="col-md-3">
				<!-- 右侧人物面板-->
				<div class="effect1 person-card">
					
				 	<a  class="member-image">
				 			<img src="/asserts/images/img_avatar.jpg" alt="Lichun Dai"/>
				 	</a>
				 	<div class="member-info">
				 		<p class="info-name">
				 		<a >
				 			Tianchi Chen
				 		</a>
				 		</p>
				 		<p>
				 			理胜力为常，力胜理为变；一时之强弱在力，千古之胜败在理！欢迎光临我的博客，希望你在此有所收获！
				 		</p>
				 	<p class="info-foot">
				 		<a class="left-card left" href="/blog/archive.html">
				 			<em>
				 				博客
				 			</em>
				 			<strong>
				 				1
				 				
				 			</strong>
				 		</a>
				 		<a class="middle-card left" href="/demo/demo.html">
				 			<em>
				 				项目
				 			</em>
				 			<strong>
				 				
				 			</strong>
				 		</a>
				 		<a class="right-card left" href="/blog/archiveAll.html">
				 			<em>
				 				随笔
				 			</em>
				 			<strong>
				 				32
				 			</strong>
				 		</a>
				 	</p>
				 	<p class="info-social-touch">
				 		<a target="_blank" href="https://github.com/yexin0710" ><img src="/asserts/images/icons/favicon_github.ico" alt="GitHub"/> </a>
						<a target="_blank" ><img src="/asserts/images/icons/favicon_5sing.ico" alt="5sing" /> </a>
						<a target="_blank" ><img src="/asserts/images/icons/favicon_changba.ico" alt="唱吧" /> </a>
						<a target="_blank" href="https://www.zhihu.com/people/yexin0710"><img src="/asserts/images/icons/favicon_zhihu.ico" alt="知乎" /> </a>
						<a target="_blank" href="http://www.jianshu.com/u/d4ee83b8e5bc"><img src="/asserts/images/icons/favicon_jianshu.ico" alt="简书" /> </a>
				 	</p>
				 	</div>
				</div>

				 <!-- TOC动态菜单-->
				  <div class="slideNavContainer">     
				</div> 				
					
			</div> 
 
		</div>
	</div>
		
<script type="text/javascript" src="/asserts/js/post.js" ></script>
<script type="text/javascript" src="/asserts/js/imageBubble.js" ></script>
<script>
	ImageBubble.init('.container img');
</script>
	
	<!-- 脚步,包括版权声明，访问次数等-->
	<footer class="footer">
	    <p class="copyright">
	    	<small>
	            <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank" title="许可协议">©</a> 2016&nbsp;&nbsp;&nbsp;&nbsp;<a href="/about/">Tianchi Chen</a>
	        </small>
	    </p>
	    <p class="more-tips">
	    	<span>Powered by Jekyll</span>&nbsp;&nbsp;&nbsp;&nbsp;
	    	<span id="busuanzi_container_site_pv">总访客<span id="busuanzi_value_site_uv" class="site-uv"></span>人</span>&nbsp;&nbsp;&nbsp;&nbsp;
	    	<span id="busuanzi_container_site_pv">总访问<span id="busuanzi_value_site_pv" class="site-pv"></span>次</span>
	    </p>  
	</footer>

<script>
//百度统计
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4cad880c1ba83acf9a10265a8a5aab1a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!--不蒜子 -->
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



</body>
</html>
